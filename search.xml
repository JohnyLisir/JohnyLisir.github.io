<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Blog创建教程]]></title>
    <url>%2F2019%2F09%2F18%2Fblog%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[#一.本地调试 ####1：启动本地服务 1$hexo s ####2: 本地 访问在浏览器中: 1https://localhost:4000 #二.发布blog到远程github 1$hexo clean &amp;&amp; hexo g &amp;&amp; hexo d]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 与原生混合开发教程]]></title>
    <url>%2F2019%2F09%2F04%2Freact-native%20%E4%B8%8E%E5%8E%9F%E7%94%9F%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[#react-native 与原生混合开发 ##1: 配置开发环境react-native环境配置（mac），请自行百度 ##2: 开发 #####1.在桌面创建一个目录 rn_project,再创建子目录 /ios, 在ios下创建一个ios工程（注意：/ios目录必须是ios工程的根目录，因为pod中有很多路径是这么引用的） ####2.: 在/ios 工程下， pod init ,产生一个 podfile文件，在里面写入pod 引用 eg:下面的pod都是从 react-native init AwesomeProject的工程中的ios-&gt;podfile 拷贝过来的，因为后期的React已经做了目录划分，官网旧的podfile格式已经不能使用了 12345678910111213141516171819202122232425262728293031323334def rn_pods # &apos;node_modules&apos;目录一般位于根目录中 pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native/&apos; pod &apos;React-Core&apos;, :path =&gt; &apos;../node_modules/react-native/React&apos; pod &apos;React-DevSupport&apos;, :path =&gt; &apos;../node_modules/react-native/React&apos; pod &apos;React-RCTActionSheet&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/ActionSheetIOS&apos; pod &apos;React-RCTAnimation&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/NativeAnimation&apos; pod &apos;React-RCTBlob&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Blob&apos; pod &apos;React-RCTImage&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Image&apos; pod &apos;React-RCTLinking&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/LinkingIOS&apos; pod &apos;React-RCTNetwork&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Network&apos; pod &apos;React-RCTSettings&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Settings&apos; pod &apos;React-RCTText&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Text&apos; pod &apos;React-RCTVibration&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/Vibration&apos; pod &apos;React-RCTWebSocket&apos;, :path =&gt; &apos;../node_modules/react-native/Libraries/WebSocket&apos; pod &apos;React-cxxreact&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/cxxreact&apos; pod &apos;React-jsi&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/jsi&apos; pod &apos;React-jsiexecutor&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/jsiexecutor&apos; pod &apos;React-jsinspector&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/jsinspector&apos; pod &apos;yoga&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/yoga&apos; pod &apos;DoubleConversion&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec&apos; pod &apos;glog&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/glog.podspec&apos; pod &apos;Folly&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/Folly.podspec&apos;endtarget &apos;RN_project&apos; do # Comment the next line if you don&apos;t want to use dynamic frameworks # use_frameworks! #react-native 0.60.4以后暂不支持 use_frameworks!,需要屏蔽，否则编译不过 pod &apos;AFNetworking&apos; # Pods for RN_project rn_podsend ####3. 在rn_project 根目录下创建一个 package.json，这个是react配置文件 12345678&#123; &quot;name&quot;: &quot;RN_project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;yarn react-native start&quot; &#125;&#125; ####4.在cd 到 rn_project 根目录下 12$yarn add react@16.8.6$yarn add react-native ####5. cd到 /ios 目录下，pod install,会将node_modules里面的podspec读取到ios项目中 剩下的就跟官方一样了 https://reactnative.cn/docs/integration-with-existing-apps/ ##注意点: 1: #react-native 0.60.4以后暂不支持 use_frameworks!,需要屏蔽，否则编译不过, podfile需要屏蔽 --&gt; # use_frameworks! FAQ: https://stackoverflow.com/questions/57152569/double-conversion-double-conversion-h-file-not-found 2: 在模拟器中，原生调用rn模块时的url，可以采用 localhost，但是一旦连接的是真机调试，则url中的localhost必须改为你的Mac电脑的ip，否则无法正常调试 3: 关于封包时的脚本 FAQ: https://www.jianshu.com/p/5f662d3c87fa]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git操作-ssh key配置相关]]></title>
    <url>%2F2019%2F08%2F10%2Fgitlab%20ssh%20key%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[#gitlab ssh key 配置 ###1: 查看本地是否已经存在 SSH Key 1$ls -al ~/.ssh ###2: 对于已经存在的直接去拷贝 1pbcopy &lt; ~/.ssh/id_rsa.pub ###3: 对于本地没有，或者需要覆盖的（tips: Overwrite (y/n)? y） 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot;]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作-.gitignore相关]]></title>
    <url>%2F2019%2F06%2F16%2Fgit%E6%93%8D%E4%BD%9C-%E6%8C%BD%E6%95%91gitignore%2F</url>
    <content type="text"><![CDATA[##对于那种已经提交到gitlab上的工程，前期 .gitignore 没配置好，导致部分该忽略的文件没忽略，这里给出急救教程！！！ 1：在master分支下1确保最新代码，且本地没有任何改动及需要提交的 2：git pull 操作1再次确保代码最新 3：git rm -r –cached .1清除本地项目目录下缓存 4: 新建or修改 .gitignore ，编辑好5: git add .6: git commit -m “add .gitignore”7: git push]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作-tag相关]]></title>
    <url>%2F2019%2F06%2F16%2Fgit-tag-commonds%2F</url>
    <content type="text"><![CDATA[#关于git的tag操作 在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; ##1：新增命令行输入git tag 就可以打一个新标签： $git tag &lt;tagname&gt;##2：查看 //查看所有(本地) $git tag 或者 $git show &lt;tagname&gt; 或者 $git tag -l //查看所有（远程） $git ls-remote --tags origin##3：将tag打到指定的commit记录上(比如之前的某次提交忘了打tag啊) $git tag 0.1.1 &lt;commitId&gt;##4：打上带有说明的tag [optional]可选的 $git tag -a 0.1.1 -m &quot;我是本次tag的相关说明&quot; &lt;commitId&gt;[optional]##5: 删除 tag（本地删除，比如你打错tag了） $git tag -d &lt;tagname&gt; 推送tag到远程 $git push origin &lt;tagname&gt; 或者 $git push --tags##6: 删除tag (远程删除) //先从本地删除 $git tag -d &lt;tagname&gt; //再从远程删除 $git push origin :refs/tags/&lt;tagname&gt;]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac通过adb安装apk的教程]]></title>
    <url>%2F2019%2F06%2F16%2FMac%E9%80%9A%E8%BF%87adb%E5%AE%89%E8%A3%85apk%E7%9A%84%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[#Mac通过adb安装apk的教程(关于mac 环境 通过adb 给安卓机（安卓系统）安装apk的教程) #1: 环境篇 ###1.1 mac上必须 安装 java 环境 可使用以下命令，查看是否安装该环境 1$ java -version 如果没有，请自行下载安装java环境 123#下载地址https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html ###1.2 mac 安装 andorid sdk通过以下命令安装 1$ brew cask install android-sdk ###1.3 mac 安装 android-platform-tools 1234$ brew cask install android-platform-tools#检测adb是否安装成功$ adb devices //如果成功了，会出现设备列表 #2: 安装篇 ###2.1 方式1 1234$ adb install &lt;apk-path&gt;#例如$ adb install xx/xxx/xx.apk ###2.2 方式2 12$ cd &lt;apk-path&gt;$ adb install xxx.apk #3: 卸载篇在有的时候我们安装新包，需要先卸载旧的包，不然会提示安装失败 ###3.1卸载apk 12345$ adb uninstall &lt;apk包名&gt;eg:$ adb uninstall cn.gowild.voiceserver.xera---如果不清楚具体包名，可通过以下方式去查看 ###3.2 查看已经安装的旧包的包名 1234567891011121314步骤如下:3.2.1$ adb shell$ cd data$ ls//如果此时出现 opendir failed, Permission denied,可以继续输入$ zhcsu ls //此时可以正常显示data目录下的内容了,如果此时没看到包名相关的文件，继续 cd data$ cd data$ ls //此时可以看到很多包文件，包括系统的包、以及第三方的包我们的包名是cn.gowild.xxxx找到具体包名后，继续走卸载流程，然后再重新安装，安装成功会出现 &apos;success&apos;提示，此时就大功告成了😆 #4: 问题篇在安装过程中出现 “ INSTALL_FAILED_ALREADY_EXISTS “ , 意思是设备上已经安装了该apk，不能重复安装，此时我们需要先卸载旧的包，然后重新安装 ###4.1 卸载apk $ adb uninstall &lt;apk包名&gt; eg: $ adb uninstall cn.gowild.voiceserver.xera###4.2 卸载完后，然后再重新安装 请参考 安装篇 安装成功会出现 &apos;success&apos;提示，此时就大功告成了😆]]></content>
      <tags>
        <tag>APK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods私有库使用-进阶之二进制]]></title>
    <url>%2F2019%2F06%2F16%2FCocoapods%E7%A7%81%E6%9C%89%E5%BA%93%E4%BD%BF%E7%94%A8-%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[#Cocoapods私有库使用-进阶之二进制 12345678参考：//Pod二进制化https://www.zybuluo.com/qidiandasheng/note/595740#%E6%BA%90%E7%A0%81%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2//iOS里的导入头文件https://www.zybuluo.com/qidiandasheng/note/602118说明：已经制作好的私有pod，每次pod install 下来都是源码，这在第一次编译时会大大增加编译时间，如果我们预先将对应的版本的pod源码制作成framework，一起提供给pod，当我们使用use_lib=1 pod install 时，切换成framework引入而不是源码引入，这样在编译的时候将大大提高编译速度，体验更好。（缺点：不能进行源码端点调试） ##1: 使用cocoapods-packager 将我们的源码制作成framework 当然，这里其实也可以制作程 .a 文件，随你选择，因为我们项目使用了oc与swift混编，podfile中使用了 ‘use_frameworks!’,所以这里就选择制作成framework详细的命令使用说明: https://www.zybuluo.com/qidiandasheng/note/595740#%E6%BA%90%E7%A0%81%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2 12345678910111213141516171.1 使用cocoapods-packager,以 &apos;GWNetworkFramework.podspec&apos;为例cd 到我们pod项目的根目录下（包含 .podspec文件），执行:$pod package GWNetworkFramework.podspec --force --embedded --no-mangle --exclude-deps --spec-sources=http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git1.2 执行此命令后，会在根目录下生成一个以podName-&#123;version&#125;命名的的文件夹,找到ios-&gt;xxxxframework 目录下，可以看到生成好的 xxx.framework,这里我们可以查看一下这个framework是否正常，比如暴露出来的头文件跟源码暴露出来的头文件，是不是一致，有没有缺少关键头文件 podName.h 文件（这个文件我们一般做整体头文件配置的，很关键哦）1.3 在根目录下新建文件夹 Frameworks-&gt;version(对应版本号,比如0.1.4), 将我们刚刚利用对应version生成的framework，copy到frameworks-&gt;version的目录下1.4 在pod项目中测试 二进制与源码的切换删除podDemo项目中的Pods文件夹（因为之前已经使用pod install，安装了源码版本的）$pod package GWLogFramework.podspec --force --embedded --no-mangle --exclude-deps --spec-sources=http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git$pod repo push gowild-app-eve_app_ios_spec GWLogFramework.podspec --allow-warnings --use-libraries --sources=&apos;http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git&apos;]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS设备 获取 udid 方法]]></title>
    <url>%2F2019%2F06%2F16%2Fios%E8%AE%BE%E5%A4%87%20%E8%8E%B7%E5%8F%96%20udid%20%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[#ios设备 获取 udid 方法： 1234567891：使用iphone自带浏览器 safari访问 https://www.pgyer.com/udid 点击获取UDID按钮，弹窗后，点击允许2: 前往手机的 设置-&gt;通用-&gt;描述文件与设备管理, 点击 “蒲公英(PGYER)”, 点击右上角安装，并输入密码以完成安装。3：安装过程完成会自动跳回 Safari浏览器 ，可以看到设备信息UDID:4：长按UDID串儿，拷贝5：将copy的UDID发送给ios开发人员（肖猛、李健、程传村）,并附上自己设备的名称，用作区分]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python代码编译成Mac软件教程]]></title>
    <url>%2F2019%2F06%2F16%2Fpython%20%E4%BB%A3%E7%A0%81%20%E7%BC%96%E8%AF%91%E6%88%90%20mac%20%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[#Python代码编译成Mac软件 ###1. Mac环境下安装 ‘py2app’ pip3 install py2app ###2. 在桌面新建一个文件夹 1eg: pyApp，将你的可执行的py脚本复制到pyApp 目录 ###3. 进入新建文件夹下 cd pyApp py2applet –make-setup xxxx.py ###4. 执行上面的命令，会产生 setup.py 文件 ###5. 继续执行 python3 setup.py py2app ###6. 会在当前文件夹下，生成 dist、build 文件夹 可运行的mac程序，就在dist 目录下 ###7. 双击即可运行该软件]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Mac-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP与H5的交互规范]]></title>
    <url>%2F2019%2F06%2F16%2FAPP%E4%B8%8Eh5%E5%90%8C%E4%B8%80%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[#为了规范化 APP与H5调用通道，采用此类型声明 APP与H5的交互，采用APP端、H5端各注册一个方法，给彼此调用，具体业务类型则在调用参数里做区分 ##（1）APP端提供方法: 方法名：jsCallNative 参数：param param = { code: 1001, data: 传递的方法参数 } 例如： js需要调起nativa方法（以ios为例,使用了WebViewJavascriptBridge框架） 1-1：native端注册方法 jsCallNative (以ios为例) //原生不提供返回值的注册 [self.bridge registerHandler:@&quot;jsCallNative&quot; handler:^(id data, WVJBResponseCallback responseCallback) { NSLog(@&quot;Log: %@&quot;, data); }]; //2:原生提供返回值的注册 [self.bridge registerHandler:@&quot;jsCallNative&quot; handler:^(id data, WVJBResponseCallback responseCallback) { responseCallback([NSNumber numberWithInt:[UIScreen mainScreen].bounds.size.height]); }]; js端代码 param = { code = 1001, data = { title: &apos;双十一活动分享&apos;, image: &apos;url&apos;, sharePlatfrom: &apos;QQ&apos;, ... } } //1：不需要返回值 bridge.callHandler(&quot;jsCallNative&quot;, param) //2：需要原生提供返回值(response为 nativa的返回值) bridge.callHandler(&quot;jsCallNative&quot;, param, function(response) { alert(&apos;Screen height:&apos; + response) })##（2）js端提供的方法: 方法名: nativeCallJs 参数：param param = { code: 1001, data: 传递的方法参数 } 例如: nativa需要调用js的方法 2-1: h5端注册方法nativeCallJs //不给原生提供返回值 bridge.registerHandler(&quot;nativeCallJs&quot;, function(data) { alert(data) }) //给原生提供返回值 bridge.registerHandler(&quot;nativeCallJs&quot;, function(data, responseCallback) { responseCallback(document.location.toString()) }) 2-2: native端调用(以ios为例) //没有返回值 [self.bridge callHandler:@&quot;nativeCallJs&quot; data:param]; //有返回值(responseData) [self.bridge callHandler:@&quot;getCurrentPageUrl&quot; data:param responseCallback:^(id responseData) { NSLog(@&quot;Current UIWebView page URL is: %@&quot;, responseData); }];##(3): 本次分享模块方法类型定义 app分享到QQ code: 1001 分享 param:]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python 搭建App服务器（Tornado）]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%9F%BA%E4%BA%8EPython%20%E6%90%AD%E5%BB%BAApp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Tornado)%2F</url>
    <content type="text"><![CDATA[#基于Python 搭建App服务器（Tornado） 说明：该教程基于CentOS7.2 64位 ##(1):环境配置(基于CentOS操作系统) CentOS 7.2 操作系统自带的 Python 版本为 2.7.5，本小册将以 Python 3.6.2 的版本进行讲解。即安装完 Python 3.6.2 后，系统上同时存在 Python 2.7.5 和 Python 3.6.2 两个版本。 12345678910111213141516171819202122232425262728293031323334351：安装依赖包$yum -y groupinstall &quot;Development tools&quot;$yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel2: 下载Python 3.6.2$wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz(注意：)如果提示 wget 命令无法找到，请先执行 yum -y install wget ,进行安装3: 创建安装目录$mkdir /usr/local/python34: 安装gcc由于 Python 3.6.2 的编译需要编译环境，故需安装 gcc。$yum -y install gcc5: 安装Python3.6.2解压 Python 3.6.2 并安装在 /usr/local/python3 目录下。$tar -xvJf Python-3.6.2.tar.xz$cd Python-3.6.2$./configure --prefix=/usr/local/python3$make &amp;&amp; make install6：创建软连$ln -s /usr/local/python3/bin/python3 /usr/bin/python3$ln -s /usr/local/python3/bin/pip3 /usr/bin/pip37: 测试 python3$python3 --version ##(2): 安装TornadoCentOS 下还无法直接使用 yum install tornado，但可以使用 pip 安装 Tornado。先执行 pip3 install –upgrade pip 命令升级 pip，再执行 pip3 install tornado 命令安装 Tornado。 测试Tornado 安装是否成功: 12$python3$import tornado ##(3): 安装MySQL 123456789$yum install mysql-devel$wget http://dev.mysql.com/get/mysql-community-$release-el7-5.noarch.rpm$rpm -ivh mysql-community-release-el7-5.noarch.rpm$yum -y install mysql-community-server$pip3 install mysqlclient$service mysqld restart#测试 MySQL 是否安装成功$systemctl status mysqld.service ##(4): 安装 SQLAlchemy 12345$pip3 install SQLAlchemy#测试 SQLAlchemy 是否安装成功$python3$import sqlalchemy ##(5): 代码编辑器mac 上推荐使用 VSCode ，搭配ftp 插件使用 ##(6): 创建 服务器工程 目录 demo 1234在root 根目录下,$cd /data (没有data目录的话, cd / ,mkdir data,然后 cd ~,再cd /data)#创建 demo文件夹$mkdir demo]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods私有库-制作教程]]></title>
    <url>%2F2019%2F06%2F16%2Fcocoapods%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[#Cocoapods 私有库方案说明: 为了使我们的项目更好的管理、模块更好的复用与维护， 经过研究决定采用 模块化配合Cocoapods的方案，以实现目的. ##注意：我们gowild-pod仓库 名字： gowild-app-eve_app_ios_spec完整的pod推送命令(以网络库的push为例) 123456789pod repo push gowild-app-eve_app_ios_spec GWNetworkFramework.podspec --allow-warnings --use-libraries --sources=&apos;http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git&apos;pod repo push gowild-app-eve_app_ios_spec GWUFileFramework.podspec --allow-warnings --use-libraries --sources=&apos;http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git&apos;pod repo push gowild-app-eve_app_ios_spec GWRouterKit.podspec --allow-warnings --use-libraries --sources=&apos;http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git&apos;对应的lintpod lib lint --allow-warnings --use-libraries --sources=&apos;http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git&apos; ###(1)需要实现的步骤: (pod lib lint -&gt; git push -&gt; git add tag and push -&gt; pod repo push) 1: 在自己的git服务器创建属于自己的cocoapods 仓库项目（仓库名如: GWSpec） 2: 在本地命令行执行 pod repo add &lt;#仓库名#&gt; &lt;#仓库项目的git地址#&gt; 如：pod repo add GWSpec https:/gitlab.gowild.top/GWSpec.git 执行完该命令后，你可以去本地 ~/.cocoapods/repo/ 目录下，会发现新增了一个与master同级名为GWSpec 的文件夹， master 是cocoapods官方库在本地的文件目录，而 GWSpec 则是我们自己搭建的私有化pods 仓库目录 3: 在自己的git服务器创建 pod项目，如 podTestLibrary, 4: 在本地创建一个pods_space的目录，命令行下 cd 到该目录下，执行命令 pod lib create podTestLibrary 的到一个xcode项目,目录结构如： PodTestLibrary ├── Example #demo APP │ ├── PodTestLibrary │ ├── PodTestLibrary.xcodeproj │ ├── PodTestLibrary.xcworkspace │ ├── Podfile #demo APP 的依赖描述文件 │ ├── Podfile.lock │ ├── Pods #demo APP 的依赖文件 │ └── Tests ├── LICENSE #开源协议 默认MIT ├── Pod #组件的目录 │ ├── Assets #资源文件 │ └── Classes #类文件 ├── PodTestLibrary.podspec #第三步要创建的podspec文件 └── README.md 5：将自己要封装的源码加入到Classes 文件夹下， 然后配置好 Podspec Metadata 下的 xxx.podspec 文件 (注：别忘了将pod测试项目的依赖版本号改为与 .podspec 文件中的一样，这点很重要哦) 6: 命令行下cd Example ，执行pod update 7: 重新打开Example 里的 xxx.xcworkspace 文件，在import 封装的某个头文件编译一下，通过就完成了第一步咯 8：命令行，在pod项目根目录下 执行 pod lib lint ，只是检查自建的pod项目，各个配置是否副歌规范。如果有错误，根据错误提示修改；如果没错执行下一步 注:如果想忽略警告 pod lib lint --allow-warnings eg: pod lib lint --allow-warnings --use-libraries --sources=&apos;http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git&apos; 9: 命令行执行 pod spec lint ,只是检查自建的pod项目能否在cocoapods体系中使用，因为目前还没推送上去，也没将私有pod项目推送到私有pod仓库，此时肯定会报错啦。请继续执行下一步 10: 将本地pod项目 push到远程git服务器(并对git 打上对应版本的tag，推送上去)， 然后命令行 执行 pod repo push GWSpec podTestLibrary.podspec ,将pod项目的索引加入自建的私有pod仓库中, 注: 如果因为警告（错误的话自己解决^_^）,可以采用命令 pod repo push GWSpec podTestLibrary.podspec --allow-warnings 11：此时在本地新建一个项目，按照(2)去使用我们自己的私有pod 关于pod迭代: 1: 确保迭代新增的代码可运行，没有错误 2: (别忘了)将 xx.podspec 文件中 version 递增一个版本，比如改为 0.2.0 3: 将要提交的代码push到私有git服务器 4: 打上tag （如第一次的tag = podspec.vresion = 0.1.0） 这次，执行 git tag 0.2.0 ,再执行 git push --tags 5: 执行 pod repo push GWSpec podTestLibrary.podspec, 再次将新version推送到私有pod仓库中 6: 此时 pod search podTestLibrary,会看到新增的version， Versions: 0.2.0, 0.1.0 【GWSpec】 7: 使用新版本的pod， 在命令执行 pod update###(2)关于私有pod 的使用 1: 在新建项目里的 podfile文件中开头出添加 source ‘https://gitlab.gowild.top/GWSpec.git&#39; source ‘https://github.com/Cocoapods/Specs.git&#39; 作用: 第一句是将我们自己的私有pod 仓库引入到Cocoapods的体系中，这样执行 pod install 才能搜到我们自己的私有pod，但是加了第一句之后，官方的pod就搜索不到了，比如此时你引用了 &apos;AFNetworking&apos;，pod install 就会提示搜索不到，此时就要加入第二句了###(3)关于 pod install 与 pod update 分别在什么时候使用 1: 执行 pod install ，会生成podfile.lock ,同时他只会补充podfile中有 项目中没有的pod工程，已经存在的他不会更新，即使有新版本了，也不会给你升级 2：执行 pod update ，原来没有的pod工程，他会给你安装最新版的，原来有的，他会给你升级到最新版 ###(4)关于pod项目push到git服务器 git add . git commit -m “Initial Commit of Library” #添加远端仓库 git remote add origin https://git.oschina.net/wuhongxing/PrivateRepo.git #推送到远端仓库 git push origin master ###(5)关于pod项目打tag,push到git服务器 添加tag git tag 0.1.0 -m &quot;first release&quot; git push --tags #推送tag到远端仓库 删除tag git tag -d 0.1.0 git push origin :refs/tags/0.1.0我在Github新建一个仓库，写了License，然后把本地一个写了很久仓库上传。先pull，因为两个仓库不同，发现refusing to merge unrelated histories，无法pull因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码，在git pull，这句代码是在git 2.9.2版本发生的，最新的版本需要添加–allow-unrelated-historiesgit pull origin master –allow-unrelated-histories #*****具体实践过程中遇到的问题***** ###question1: 123原来的GWLogFramework 工程引用了mars.framework，没出现啥问题l；但是自己新建一个pod工程，将核心代码以及mars.framework移进去，报 #include&lt;limits&gt; file not found 错误解决： 经过2天的各种排查，百度、谷歌，没找到很相似的问题答案，尝试将GWMarsLogManager.m 改为 xxx.mm 成功跑起来了 ###question2: 123456789101112131415161718192021222324252627对于私有pod 依赖于私有pod这种情况(比如：我们的GWNetworkFrameWork依赖于GWLogFramework)，有使用和检测两方面的注意点,1:使用 xxxx.podspec下直接应用#------------------文件分级------------------##s.subspec &apos;Vendor&apos; do |ss|#ss.source_files = &apos;GWNetworkFramework/Classes/Vendor/**/*&apos;#ends.subspec &apos;Core&apos; do |ss|#ss.dependency &apos;GWNetworkFramework/Vendor&apos;ss.source_files = &apos;GWNetworkFramework/Classes/Core/**/*&apos;ends.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;s.dependency &apos;CocoaAsyncSocket&apos;s.dependency &apos;YYModel&apos;s.dependency &apos;YYCache&apos;s.dependency &apos;SocketRocket&apos;s.dependency &apos;GWLogFramework&apos;s.frameworks = &apos;UIKit&apos;, &apos;CFNetwork&apos;同时，新pod的example 工程的podfile顶部需引入2个source源2:检测注意: source1Url,source2Url,分别代表着cocoapods官方的仓库git地址以及自己的私有库git地址lint的时候使用 pod lib lint --allow-warnings --sources=&apos;source1Url,source2Url&apos;push的时候用 pod repo push GWSpec GWNetworkFramework.podspec --sources=&apos;source1Url,source2Url&apos; #*****参考文档 ***** 123456789101112131415Cocoapods 制作参考1： https://www.jianshu.com/p/d6a592d6fced参考2：https://www.jianshu.com/p/07f7854cd563Cocoapods制作-bundle制作及使用参考：https://www.jianshu.com/p/055906d5ae27Cocoapods framework制作参考: http://www.cnblogs.com/brycezhang/p/4117180.htmlCocoapods podfile 相关介绍参考: https://www.jianshu.com/p/b8b889610b7eCocoapods 制作中肯定遇到的问题参考：https://www.jianshu.com/p/1f56c3d78b52 ##2: cocoapods二进制packager 的使用 eg: pod package GWNetworkFramework.podspec --force --embedded --no-mangle --exclude-deps --subspecs=Core --spec-sources=http://gitlab.gowild.top/app/Eve_App_iOS_spec.git,https://github.com/CocoaPods/Specs.git 参考: https://www.zybuluo.com/qidiandasheng/note/595740]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
</search>
